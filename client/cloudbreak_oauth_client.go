package client

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	httptransport "github.com/go-swagger/go-swagger/httpkit/client"

	"crypto/tls"
	"errors"
	"fmt"
	"github.com/go-swagger/go-swagger/strfmt"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"strings"
	"github.com/ernesto-jimenez/httplogger"
	"log"
	"os"
	"time"
)

// This is nearly identical with http.DefaultTransport
var TransportConfig = &http.Transport{
	Proxy:           http.ProxyFromEnvironment,
	TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	Dial: (&net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
	}).Dial,
	TLSHandshakeTimeout:   10 * time.Second,
	ExpectContinueTimeout: 1 * time.Second,
}

var LoggedTransportConfig = httplogger.NewLoggedTransport(TransportConfig, newLogger())

// NewHTTPClient creates a new cloudbreak HTTP client.
func NewOAuth2HTTPClient(address string, username string, password string) *Cloudbreak {
	transport := httptransport.New(address, "/cb/api/v1", []string{"https"})
	token := getOAuth2Token("https://"+address+"/identity/oauth/authorize", username, password, "cloudbreak_shell")
	transport.DefaultAuthentication = httptransport.BearerToken(token)

	transport.Transport = LoggedTransportConfig
	return New(transport, strfmt.Default)
}

func getOAuth2Token(identityUrl string, username string, password string, clientId string) string {
	form := url.Values{"credentials": {fmt.Sprintf(`{"username":"%s","password":"%s"}`, username, password)}}
	req, _ := http.NewRequest("POST", fmt.Sprintf("%s?response_type=token&client_id=%s", identityUrl, clientId), strings.NewReader(form.Encode()))
	req.Header.Add("Accept", "application/x-www-form-urlencoded")
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	client := &http.Client{
		Transport: LoggedTransportConfig,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return errors.New("Don't redirect!")
		},
	}

	resp, _ := client.Do(req)
	location := resp.Header.Get("Location")
	regexp := regexp.MustCompile("access_token=(.*)&expires_in")
	tokenBytes := regexp.Find([]byte(location))
	tokenString := string(tokenBytes)
	token := tokenString[13 : len(tokenString)-11]
	return token
}

type httpLogger struct {
	log *log.Logger
}

func newLogger() *httpLogger {
	return &httpLogger{
		log: log.New(os.Stderr, "", log.LstdFlags),
	}
}

func (l *httpLogger) LogRequest(req *http.Request) {
	l.log.Printf(
		"Request %s %s",
		req.Method,
		req.URL.String(),
	)
}

func (l *httpLogger) LogResponse(req *http.Request, res *http.Response, err error, duration time.Duration) {
	duration /= time.Millisecond
	if err != nil {
		l.log.Println(err)
	} else {
		l.log.Printf(
			"Response method:%s status:%d duration:%dms req_url:%s",
			req.Method,
			res.StatusCode,
			duration,
			req.URL.String(),
		)
	}
}
